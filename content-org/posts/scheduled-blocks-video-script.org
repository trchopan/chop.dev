#+hugo_base_dir: ~/Sync/chop-ink/
#+hugo_tags: scheduled blocks video script
#+hugo_custom_front_matter: :cover /ox-hugo/scheduled-block-script_20220301_234604.png
#+hugo_custom_front_matter: :images /ox-hugo/scheduled-block-script_20220301_234604.png

#+TITLE: scheduled-blocks video script
#+AUTHOR: Chop Tr (chop.ink)
#+DATE: <2022-03-01 Tue>
#+DESCRIPTION: Đây là một chương trình viết lại của một repo khác cũng đã thực hiện việc tính toán block slot leader trên blockchain Cardano. Source kia thì viết bằng Python. Mình quyết định mục tiêu sẽ là convert hết các Chức năng và Công thức của repo đó thành Haskell, phục vụ việc học ngôn ngữ này.


* Mục đích của dự án

Haskell là một ngôn ngữ rất khó, một thế giới mới đối với bất kỳ kỹ sư lập trình nào đã làm việc quá lâu với OOP hay thế giới imperative programing (tạm gọi lập trình mệnh lệnh).

Có 2 mô hình lập trình (hay còn gọi là paradigms) là imperative (mệnh lệnh) và functional (chức năng).

#+begin_src java
int total = 0;

for (int i = 0; i < 10; i++) {
    total = total + i;
}
#+end_src

#+begin_src haskell
sum [1 .. 10]

sum :: [Int] -> Int
sum [n]    = n
sum (n:ns) = n + sum ns
#+end_src

Link: https://www.youtube.com/watch?v=sqV3pL5x8PI

2 ví dụ điển hình nhất của 2 paradigms này là Java - imperative và Haskell - functional. Ở đây không phải là so sánh tốt xấu, tất cả paradigms đều là 1 nguyên tác và lý luận để giải quyết vấn đề. Chỉ là người sử dụng hiểu mình muốn gì và áp dụng như thế nào. Các bạn có thể hiểu nhg paradigms này như Đạo, có đạo Phật, đạo Chúa, v.v thì trong lập trình cũng vậy.

Đối với kinh nghiệm của mình thì không có gì hiệu quả bằng tự đặt ra 1 mục đích cho bản thân. Một cái gì đó mà mình có thể đạt đc để tập trung hết tất cả sức lực để tiến tới. Thông qua đó nhg thứ trên quãng đường sẽ trở thành kiến thức và kinh nghiệm.

Trên quãng đường học Haskell, không ít lần khó quá mình đã bỏ cuộc. Ngồi nghĩ phải chi học Rust thì hay ta (Ah tại trong lúc thực hiện dự án mình phải đọc 1 số implementation viết bằng Rust). Nhg nhờ kiên trì với mục tiêu tự đặt ra mình cũng đã hoàn thành đc thứ mình muốn.

Thì đây là một dự án mà mình tự đặt ra cho bản thân khi bắt đầu học Haskell (lần thứ 3 😛) .

Giới thiệu sơ thì mình là một Stake Pool opperator. Là một người vận hành hồ cổ phần. Trên hệ blockchain Cardano, nên mình cũng có một ít kiến thức về blockchain và hệ thống vận hành của Cardano.

Thì việc staking và vận hành hồ Cardano khác với các hệ blockchain khác là nó có thể tính trước được block đến hồ chính xác vào lúc nào. Công thức tính thì dựa trên khoá VRF Sign key (Verifiable Random Function).

Đây là một chương trình viết lại của một repo khác cũng đã thực hiện việc tính toán này, source kia thì viết bằng Python. Mình quyết định mục tiêu sẽ là convert hết các Chức năng và Công thức của repo đó thành Haskell, phục vụ việc học ngôn ngữ này.


* Con đường

** Lời đầu

Video này mình đang không nhắm tới việc học Haskell từ căn bản. Mà chỉ muốn đi qua các giai đoạn mà mình trải qua trong quá trình thực hiện dự án. Nên sẽ đi khá nhanh qua các bước, hy vọng qua chia sẽ có thể làm cơ sở demo để các bạn thấy sự hứng thú trong quá trình làm việc với Haskell.


** Chạy chương trình với args

Chương trình này sẽ là một chương trình command line. Nên việc đầu tiên mà mình học cách chạy chương trình với các arguments (hiểu là điều kiện chạy).

=Ví dụ:= Khi mình muốn tính các block đã được giao trong quá khứ (history) thì mình sẽ chạy chương trình như sau:

#+begin_src bash
scheduled-blocks history --epoch 321
#+end_src

*** Demo

https://hackage.haskell.org/package/optparse-applicative


** Query API

Chương trình này sẽ cũng giống như repo cũ, sẽ query API để lấy các "nguyên liệu" để tính. Đây cũng là một tác vụ phổ biến đối với bất kỳ chương trình nào và các bạn lập trình lâu năm chắc cũng đã phải làm công việc này cả triệu lần.

Trong Haskell thì khá là strong type. Strong hay Weak thì có nhiều tranh cãi. Nhg về cơ bản nó là ngôn ngữ có type safety check, and statically typing.

Nên khi query API, bắt buộc các bạn phải có kiểu Data để map hoặc parse kết quả trả về.

*** Demo

https://hackage.haskell.org/package/aeson

https://app.quicktype.io/


** Chuẩn bị kết quả mẫu - Test Samples

Đây là một dự án viết dựa trên công thức đã có sẵn nên mình cần chuẩn bị một loạt các kết quả mong muốn để thực hiện việc so sánh kết quả trong lúc thực hiện - implement.

Mình sẽ đi qua tài liệu mà mình viết khi chuẩn bị các thông số. (Tài liệu này đc viết bằng tiếng Anh để bất kỳ ai cũng có thể tái thực hiện các bước nếu muốn).

https://chop.ink/posts/test-procedure-for-scheduled-blocks/


** Viết test case

Thói quen khi lập trình của mình. Các bạn lập trình lâu năm sẽ hiểu đc thói quen này đáng giá như thế nào. Vì các chương trình của các bạn khá là đồ sộ, không dễ dàng để spin up (khởi động) chương trình lên và test nhanh đc.

Lưu ý là điều trên đúng với các bạn lập trình Backend. Bên frontend có các công cụ để hot-reload để phục vụ công việc này.

Nên khi nhảy vào làm project một trong những thứ mình học trước tiên là cách viết test case.

*** Demo

https://hspec.github.io/


* Nối tất cả lại với nhau

** Demo toàn bộ chương trình


* Lời Kết

Qua trải nghiệm thì chương trình này cũng không quá khó. Nhg nó thể hiện được khá nhiều các chức năng của một chương trình viết trên Haskell.

Ở đây mình chưa có nhiều kiến thức sâu về Haskell vì mới học đc vài tháng. Nên chưa xử lý đc các kiểu dữ liệu, xử lý cấu trúc thư mục hay cũng như chưa nắm đc các cách lập trình chạy concurrency. Nghiên cứu tham khảo thì Haskell khá mạnh với Software Transactional Memory mechanism (STM) - Cơ chế bộ nhớ giao dịch phần mềm. Vì nó tính chất thuần functional, Haskell có khả năng đảm bảo các biến STM không đc sửa đổi bên ngoài các monad STM.

Chương trình của mình cũng có thể đc cải tiến hơn nếu chạy concurrent các API query thông số. Mình cũng đã chạy thử concurrent các phép tính slot leader nhưng kết quả hoàn toàn không tốt hơn do các phép tính đều là pure function nên cũng đc Haskell tự tối ưu sẵn trong quá trình thực thi (execution).

Có một điểm trong quá trình thực hiện dự án là việc làm quen với các tài liệu và hỏi đáp trên StackOverflow. Lúc đầu chắc các bạn nào mới tiếp cận sẽ thấy hơi bỡ ngỡ vì các tài liệu khá là khó theo. Điều này đúng với các thư viện cũ hay thư viện cốt lõi của Haskell, có vẻ như các bác maintainer cũng lười viết chi tiết mô tả hướng dẫn vì mặc nhiên đây là các kiến thức cơ bản. Với các thư viện nổi tiếng và nhiều người sử dụng cũng như nhiều người maintain thì đc viết khá rõ ràng và đầy đủ.
